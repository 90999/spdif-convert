-- Generated by PERL program wishbone.pl. Do not edit this file.
--
-- For defines see wishbone0.defines
--
-- Generated Sat Aug 18 21:43:39 2012
--
-- Wishbone masters:
--   wb0m0
--   wb0m1
--   wb0m2
--
-- Wishbone slaves:
--   wb0s0
--     baseadr 0x00000000 - size 0x00000080
--     baseadr 0x80000000 - size 0x40000000
--   wb0s1
--     baseadr 0x10000000 - size 0x00000080
--     baseadr 0xC0000000 - size 0x40000000
--   wb0s2
--     baseadr 0x20000000 - size 0x00001000
--   wb0s3
--     baseadr 0x30000000 - size 0x00000020
--   wb0s4
--     baseadr 0x30000400 - size 0x00000080
--   wb0s5
--     baseadr 0x40000000 - size 0x00001000
--   wb0s6
--     baseadr 0x30000800 - size 0x00000080
--   wb0s7
--     baseadr 0x30000C00 - size 0x00000008
--   wb0s8
--     baseadr 0x50000000 - size 0x00001000
-----------------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

package intercon0_package is


function "and" (
  l : std_logic_vector;
  r : std_logic)
return std_logic_vector;
end intercon0_package;
package body intercon0_package is

function "and" (
  l : std_logic_vector;
  r : std_logic)
return std_logic_vector is
  variable result : std_logic_vector(l'range);
begin  -- "and"
  for i in l'range loop
  result(i) := l(i) and r;
end loop;  -- i
return result;
end "and";
end intercon0_package;

library IEEE;
use IEEE.std_logic_1164.all;

entity trafic_supervision0 is

  generic (
    priority     : integer := 1;
    tot_priority : integer := 2);

  port (
    bg           : in  std_logic;       -- bus grant
    ce           : in  std_logic;       -- clock enable
    trafic_limit : out std_logic;
    clk          : in  std_logic;
    reset        : in  std_logic);

end trafic_supervision0;

architecture rtl of trafic_supervision0 is

  signal shreg : std_logic_vector(tot_priority-1 downto 0);
  signal cntr : integer range 0 to tot_priority;

begin  -- rtl

  -- purpose: holds information of usage of latest cycles
  -- type   : sequential
  -- inputs : clk, reset, ce, bg
  -- outputs: shreg('left)
  sh_reg: process (clk)
  begin  -- process shreg
    if clk'event and clk = '1' then  -- rising clock edge
      if ce='1' then
        shreg <= shreg(tot_priority-2 downto 0) & bg;
      end if;
    end if;
  end process sh_reg;

  -- purpose: keeps track of used cycles
  -- type   : sequential
  -- inputs : clk, reset, shreg('left), bg, ce
  -- outputs: trafic_limit
  counter: process (clk, reset)
  begin  -- process counter
    if reset = '1' then                 -- asynchronous reset (active hi)
      cntr <= 0;
      trafic_limit <= '0';
    elsif clk'event and clk = '1' then  -- rising clock edge
      if ce='1' then
        if bg='1' and shreg(tot_priority-1)/='1' then
          cntr <= cntr + 1;
          if cntr=priority-1 then
            trafic_limit <= '1';
          end if;
        elsif bg='0' and shreg(tot_priority-1)='1' then
          cntr <= cntr - 1;
          if cntr=priority then
            trafic_limit <= '0';
          end if;
        end if;
      end if;
    end if;
  end process counter;

end rtl;

library IEEE;
use IEEE.std_logic_1164.all;
use work.intercon0_package.all;

entity intercon0 is
  port (
  -- wishbone master port(s)
  -- wb0m0
  wb0m0_dat_i : out std_logic_vector(31 downto 0);
  wb0m0_ack_i : out std_logic;
  wb0m0_dat_o : in  std_logic_vector(31 downto 0);
  wb0m0_we_o  : in  std_logic;
  wb0m0_sel_o : in  std_logic_vector(3 downto 0);
  wb0m0_adr_o : in  std_logic_vector(31 downto 0);
  wb0m0_cyc_o : in  std_logic;
  wb0m0_stb_o : in  std_logic;
  -- wb0m1
  wb0m1_dat_i : out std_logic_vector(31 downto 0);
  wb0m1_ack_i : out std_logic;
  wb0m1_err_i : out std_logic;
  wb0m1_rty_i : out std_logic;
  wb0m1_dat_o : in  std_logic_vector(31 downto 0);
  wb0m1_we_o  : in  std_logic;
  wb0m1_sel_o : in  std_logic_vector(3 downto 0);
  wb0m1_adr_o : in  std_logic_vector(31 downto 0);
  wb0m1_cyc_o : in  std_logic;
  wb0m1_stb_o : in  std_logic;
  -- wb0m2
  wb0m2_dat_i : out std_logic_vector(31 downto 0);
  wb0m2_ack_i : out std_logic;
  wb0m2_err_i : out std_logic;
  wb0m2_rty_i : out std_logic;
  wb0m2_dat_o : in  std_logic_vector(31 downto 0);
  wb0m2_we_o  : in  std_logic;
  wb0m2_sel_o : in  std_logic_vector(3 downto 0);
  wb0m2_adr_o : in  std_logic_vector(31 downto 0);
  wb0m2_cyc_o : in  std_logic;
  wb0m2_stb_o : in  std_logic;
  -- wishbone slave port(s)
  -- wb0s0
  wb0s0_dat_o : in  std_logic_vector(31 downto 0);
  wb0s0_ack_o : in  std_logic;
  wb0s0_err_o : in  std_logic;
  wb0s0_rty_o : in  std_logic;
  wb0s0_dat_i : out std_logic_vector(31 downto 0);
  wb0s0_we_i  : out std_logic;
  wb0s0_sel_i : out std_logic_vector(3 downto 0);
  wb0s0_adr_i : out std_logic_vector(31 downto 0);
  wb0s0_cyc_i : out std_logic;
  wb0s0_stb_i : out std_logic;
  -- wb0s1
  wb0s1_dat_o : in  std_logic_vector(31 downto 0);
  wb0s1_ack_o : in  std_logic;
  wb0s1_err_o : in  std_logic;
  wb0s1_rty_o : in  std_logic;
  wb0s1_dat_i : out std_logic_vector(31 downto 0);
  wb0s1_we_i  : out std_logic;
  wb0s1_sel_i : out std_logic_vector(3 downto 0);
  wb0s1_adr_i : out std_logic_vector(31 downto 0);
  wb0s1_cyc_i : out std_logic;
  wb0s1_stb_i : out std_logic;
  -- wb0s2
  wb0s2_dat_o : in  std_logic_vector(31 downto 0);
  wb0s2_ack_o : in  std_logic;
  wb0s2_dat_i : out std_logic_vector(31 downto 0);
  wb0s2_we_i  : out std_logic;
  wb0s2_sel_i : out std_logic_vector(3 downto 0);
  wb0s2_adr_i : out std_logic_vector(31 downto 0);
  wb0s2_cyc_i : out std_logic;
  wb0s2_stb_i : out std_logic;
  -- wb0s3
  wb0s3_dat_o : in  std_logic_vector(31 downto 0);
  wb0s3_ack_o : in  std_logic;
  wb0s3_dat_i : out std_logic_vector(31 downto 0);
  wb0s3_we_i  : out std_logic;
  wb0s3_sel_i : out std_logic_vector(3 downto 0);
  wb0s3_adr_i : out std_logic_vector(31 downto 0);
  wb0s3_cyc_i : out std_logic;
  wb0s3_stb_i : out std_logic;
  -- wb0s4
  wb0s4_dat_o : in  std_logic_vector(31 downto 0);
  wb0s4_ack_o : in  std_logic;
  wb0s4_err_o : in  std_logic;
  wb0s4_dat_i : out std_logic_vector(31 downto 0);
  wb0s4_we_i  : out std_logic;
  wb0s4_sel_i : out std_logic_vector(3 downto 0);
  wb0s4_adr_i : out std_logic_vector(31 downto 0);
  wb0s4_cyc_i : out std_logic;
  wb0s4_stb_i : out std_logic;
  -- wb0s5
  wb0s5_dat_o : in  std_logic_vector(31 downto 0);
  wb0s5_ack_o : in  std_logic;
  wb0s5_dat_i : out std_logic_vector(31 downto 0);
  wb0s5_we_i  : out std_logic;
  wb0s5_sel_i : out std_logic_vector(3 downto 0);
  wb0s5_adr_i : out std_logic_vector(31 downto 2);
  wb0s5_cti_i : out std_logic_vector(2 downto 0);
  wb0s5_bte_i : out std_logic_vector(1 downto 0);
  wb0s5_cyc_i : out std_logic;
  wb0s5_stb_i : out std_logic;
  -- wb0s6
  wb0s6_dat_o : in  std_logic_vector(31 downto 0);
  wb0s6_ack_o : in  std_logic;
  wb0s6_err_o : in  std_logic;
  wb0s6_dat_i : out std_logic_vector(31 downto 0);
  wb0s6_we_i  : out std_logic;
  wb0s6_sel_i : out std_logic_vector(3 downto 0);
  wb0s6_adr_i : out std_logic_vector(31 downto 0);
  wb0s6_cyc_i : out std_logic;
  wb0s6_stb_i : out std_logic;
  -- wb0s7
  wb0s7_dat_o : in  std_logic_vector(31 downto 0);
  wb0s7_ack_o : in  std_logic;
  wb0s7_dat_i : out std_logic_vector(31 downto 0);
  wb0s7_we_i  : out std_logic;
  wb0s7_sel_i : out std_logic_vector(3 downto 0);
  wb0s7_adr_i : out std_logic_vector(31 downto 0);
  wb0s7_cyc_i : out std_logic;
  wb0s7_stb_i : out std_logic;
  -- wb0s8
  wb0s8_dat_o : in  std_logic_vector(31 downto 0);
  wb0s8_ack_o : in  std_logic;
  wb0s8_dat_i : out std_logic_vector(31 downto 0);
  wb0s8_we_i  : out std_logic;
  wb0s8_sel_i : out std_logic_vector(3 downto 0);
  wb0s8_adr_i : out std_logic_vector(31 downto 2);
  wb0s8_cti_i : out std_logic_vector(2 downto 0);
  wb0s8_bte_i : out std_logic_vector(1 downto 0);
  wb0s8_cyc_i : out std_logic;
  wb0s8_stb_i : out std_logic;
  -- clock and reset
  clk   : in std_logic;
  reset : in std_logic);
end intercon0;
architecture rtl of intercon0 is
  signal wb0m0_bg : std_logic; -- bus grant
  signal wb0m1_bg : std_logic; -- bus grant
  signal wb0m2_bg : std_logic; -- bus grant
  signal wb0s0_ss : std_logic; -- slave select
  signal wb0s1_ss : std_logic; -- slave select
  signal wb0s2_ss : std_logic; -- slave select
  signal wb0s3_ss : std_logic; -- slave select
  signal wb0s4_ss : std_logic; -- slave select
  signal wb0s5_ss : std_logic; -- slave select
  signal wb0s6_ss : std_logic; -- slave select
  signal wb0s7_ss : std_logic; -- slave select
  signal wb0s8_ss : std_logic; -- slave select
begin  -- rtl
arbiter_sharedbus: block
  signal wb0m0_bg_1, wb0m0_bg_2, wb0m0_bg_q : std_logic;
  signal wb0m1_bg_1, wb0m1_bg_2, wb0m1_bg_q : std_logic;
  signal wb0m2_bg_1, wb0m2_bg_2, wb0m2_bg_q : std_logic;
  signal wb0m0_trafic_ctrl_limit : std_logic;
  signal wb0m1_trafic_ctrl_limit : std_logic;
  signal wb0m2_trafic_ctrl_limit : std_logic;
  signal ack, ce, idle :std_logic;
begin -- arbiter
ack <= wb0s0_ack_o or wb0s1_ack_o or wb0s2_ack_o or wb0s3_ack_o or wb0s4_ack_o or wb0s5_ack_o or wb0s6_ack_o or wb0s7_ack_o or wb0s8_ack_o;

trafic_supervision_1 : entity work.trafic_supervision0
generic map(
  priority => 1,
  tot_priority => 3)
port map(
  bg => wb0m0_bg,
  ce => ce,
  trafic_limit => wb0m0_trafic_ctrl_limit,
  clk => clk,
  reset => reset);

trafic_supervision_2 : entity work.trafic_supervision0
generic map(
  priority => 1,
  tot_priority => 3)
port map(
  bg => wb0m1_bg,
  ce => ce,
  trafic_limit => wb0m1_trafic_ctrl_limit,
  clk => clk,
  reset => reset);

trafic_supervision_3 : entity work.trafic_supervision0
generic map(
  priority => 1,
  tot_priority => 3)
port map(
  bg => wb0m2_bg,
  ce => ce,
  trafic_limit => wb0m2_trafic_ctrl_limit,
  clk => clk,
  reset => reset);

process(clk,reset)
begin
if reset='1' then
  wb0m0_bg_q <= '0';
elsif clk'event and clk='1' then
if wb0m0_bg_q='0' then
  wb0m0_bg_q <= wb0m0_bg;
elsif ack='1' then
  wb0m0_bg_q <= '0';
end if;
end if;
end process;

process(clk,reset)
begin
if reset='1' then
  wb0m1_bg_q <= '0';
elsif clk'event and clk='1' then
if wb0m1_bg_q='0' then
  wb0m1_bg_q <= wb0m1_bg;
elsif ack='1' then
  wb0m1_bg_q <= '0';
end if;
end if;
end process;

process(clk,reset)
begin
if reset='1' then
  wb0m2_bg_q <= '0';
elsif clk'event and clk='1' then
if wb0m2_bg_q='0' then
  wb0m2_bg_q <= wb0m2_bg;
elsif ack='1' then
  wb0m2_bg_q <= '0';
end if;
end if;
end process;

idle <= '1' when wb0m0_bg_q='0' and wb0m1_bg_q='0' and wb0m2_bg_q='0' else '0';
wb0m0_bg_1 <= '1' when idle='1' and wb0m0_cyc_o='1' and wb0m0_trafic_ctrl_limit='0' else '0';
wb0m1_bg_1 <= '1' when idle='1' and wb0m1_cyc_o='1' and wb0m1_trafic_ctrl_limit='0' and (wb0m0_bg_1='0') else '0';
wb0m2_bg_1 <= '1' when idle='1' and wb0m2_cyc_o='1' and wb0m2_trafic_ctrl_limit='0' and (wb0m0_bg_1='0' and wb0m1_bg_1='0') else '0';
wb0m0_bg_2 <= '1' when idle='1' and (wb0m0_bg_1='0' and wb0m1_bg_1='0' and wb0m2_bg_1='0') and wb0m0_cyc_o='1' else '0';
wb0m1_bg_2 <= '1' when idle='1' and (wb0m0_bg_1='0' and wb0m1_bg_1='0' and wb0m2_bg_1='0' and wb0m0_bg_2='0') and wb0m1_cyc_o='1' else '0';
wb0m2_bg_2 <= '1' when idle='1' and (wb0m0_bg_1='0' and wb0m1_bg_1='0' and wb0m2_bg_1='0' and wb0m0_bg_2='0' and wb0m1_bg_2='0') and wb0m2_cyc_o='1' else '0';
wb0m0_bg <= wb0m0_bg_q or wb0m0_bg_1 or wb0m0_bg_2;
wb0m1_bg <= wb0m1_bg_q or wb0m1_bg_1 or wb0m1_bg_2;
wb0m2_bg <= wb0m2_bg_q or wb0m2_bg_1 or wb0m2_bg_2;
ce <= wb0m0_cyc_o or wb0m1_cyc_o or wb0m2_cyc_o when idle='1' else '0';

end block arbiter_sharedbus;

decoder:block
  signal adr : std_logic_vector(31 downto 0);
begin
adr <= (wb0m0_adr_o and wb0m0_bg) or (wb0m1_adr_o and wb0m1_bg) or (wb0m2_adr_o and wb0m2_bg);
wb0s0_ss <= '1' when adr(31 downto 7)="0000000000000000000000000" else
'1' when adr(31 downto 30)="10" else
'0';
wb0s1_ss <= '1' when adr(31 downto 7)="0001000000000000000000000" else
'1' when adr(31 downto 30)="11" else
'0';
wb0s2_ss <= '1' when adr(31 downto 12)="00100000000000000000" else
'0';
wb0s3_ss <= '1' when adr(31 downto 5)="001100000000000000000000000" else
'0';
wb0s4_ss <= '1' when adr(31 downto 7)="0011000000000000000001000" else
'0';
wb0s5_ss <= '1' when adr(31 downto 12)="01000000000000000000" else
'0';
wb0s6_ss <= '1' when adr(31 downto 7)="0011000000000000000010000" else
'0';
wb0s7_ss <= '1' when adr(31 downto 3)="00110000000000000000110000000" else
'0';
wb0s8_ss <= '1' when adr(31 downto 12)="01010000000000000000" else
'0';
wb0s0_adr_i <= adr(31 downto 0);
wb0s1_adr_i <= adr(31 downto 0);
wb0s2_adr_i <= adr(31 downto 0);
wb0s3_adr_i <= adr(31 downto 0);
wb0s4_adr_i <= adr(31 downto 0);
wb0s5_adr_i <= adr(31 downto 2);
wb0s6_adr_i <= adr(31 downto 0);
wb0s7_adr_i <= adr(31 downto 0);
wb0s8_adr_i <= adr(31 downto 2);
end block decoder;

mux: block
  signal cyc, stb, we, ack : std_logic;
  signal rty : std_logic;
  signal err : std_logic;
  signal sel : std_logic_vector(3 downto 0);
  signal dat_m2s, dat_s2m : std_logic_vector(31 downto 0);
begin
cyc <= (wb0m0_cyc_o and wb0m0_bg) or (wb0m1_cyc_o and wb0m1_bg) or (wb0m2_cyc_o and wb0m2_bg);
wb0s0_cyc_i <= wb0s0_ss and cyc;
wb0s1_cyc_i <= wb0s1_ss and cyc;
wb0s2_cyc_i <= wb0s2_ss and cyc;
wb0s3_cyc_i <= wb0s3_ss and cyc;
wb0s4_cyc_i <= wb0s4_ss and cyc;
wb0s5_cyc_i <= wb0s5_ss and cyc;
wb0s6_cyc_i <= wb0s6_ss and cyc;
wb0s7_cyc_i <= wb0s7_ss and cyc;
wb0s8_cyc_i <= wb0s8_ss and cyc;
stb <= (wb0m0_stb_o and wb0m0_bg) or (wb0m1_stb_o and wb0m1_bg) or (wb0m2_stb_o and wb0m2_bg);
wb0s0_stb_i <= stb;
wb0s1_stb_i <= stb;
wb0s2_stb_i <= stb;
wb0s3_stb_i <= stb;
wb0s4_stb_i <= stb;
wb0s5_stb_i <= stb;
wb0s6_stb_i <= stb;
wb0s7_stb_i <= stb;
wb0s8_stb_i <= stb;
we <= (wb0m0_we_o and wb0m0_bg) or (wb0m1_we_o and wb0m1_bg) or (wb0m2_we_o and wb0m2_bg);
wb0s0_we_i <= we;
wb0s1_we_i <= we;
wb0s2_we_i <= we;
wb0s3_we_i <= we;
wb0s4_we_i <= we;
wb0s5_we_i <= we;
wb0s6_we_i <= we;
wb0s7_we_i <= we;
wb0s8_we_i <= we;
ack <= wb0s0_ack_o or wb0s1_ack_o or wb0s2_ack_o or wb0s3_ack_o or wb0s4_ack_o or wb0s5_ack_o or wb0s6_ack_o or wb0s7_ack_o or wb0s8_ack_o;
wb0m0_ack_i <= ack and wb0m0_bg;
wb0m1_ack_i <= ack and wb0m1_bg;
wb0m2_ack_i <= ack and wb0m2_bg;
rty <= wb0s0_rty_o or wb0s1_rty_o;
wb0m1_rty_i <= rty;
wb0m2_rty_i <= rty;
err <= wb0s0_err_o or wb0s1_err_o or wb0s4_err_o or wb0s6_err_o;
wb0m1_err_i <= err;
wb0m2_err_i <= err;
sel <= (wb0m0_sel_o and wb0m0_bg) or (wb0m1_sel_o and wb0m1_bg) or (wb0m2_sel_o and wb0m2_bg);
wb0s0_sel_i <= sel;
wb0s1_sel_i <= sel;
wb0s2_sel_i <= sel;
wb0s3_sel_i <= sel;
wb0s4_sel_i <= sel;
wb0s5_sel_i <= sel;
wb0s6_sel_i <= sel;
wb0s7_sel_i <= sel;
wb0s8_sel_i <= sel;
dat_m2s <= (wb0m0_dat_o and wb0m0_bg) or (wb0m1_dat_o and wb0m1_bg) or (wb0m2_dat_o and wb0m2_bg);
wb0s0_dat_i <= dat_m2s;
wb0s1_dat_i <= dat_m2s;
wb0s2_dat_i <= dat_m2s;
wb0s3_dat_i <= dat_m2s;
wb0s4_dat_i <= dat_m2s;
wb0s5_dat_i <= dat_m2s;
wb0s6_dat_i <= dat_m2s;
wb0s7_dat_i <= dat_m2s;
wb0s8_dat_i <= dat_m2s;
dat_s2m <= (wb0s0_dat_o and wb0s0_ss) or (wb0s1_dat_o and wb0s1_ss) or (wb0s2_dat_o and wb0s2_ss) or (wb0s3_dat_o and wb0s3_ss) or (wb0s4_dat_o and wb0s4_ss) or (wb0s5_dat_o and wb0s5_ss) or (wb0s6_dat_o and wb0s6_ss) or (wb0s7_dat_o and wb0s7_ss) or (wb0s8_dat_o and wb0s8_ss);
wb0m0_dat_i <= dat_s2m;
wb0m1_dat_i <= dat_s2m;
wb0m2_dat_i <= dat_s2m;
wb0s5_cti_i <= (others=>'0');
wb0s8_cti_i <= (others=>'0');
wb0s5_bte_i <= (others=>'0');
wb0s8_bte_i <= (others=>'0');
end block mux;

end rtl;

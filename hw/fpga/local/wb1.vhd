-- Generated by PERL program wishbone.pl. Do not edit this file.
--
-- For defines see wishbone1.defines
--
-- Generated Tue Aug 21 00:33:11 2012
--
-- Wishbone masters:
--   wb1m0
--
-- Wishbone slaves:
--   wb1s0
--     baseadr 0x0000 - size 0x8000
--   wb1s1
--     baseadr 0x8000 - size 0x2000
-----------------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

package intercon1_package is


function "and" (
  l : std_logic_vector;
  r : std_logic)
return std_logic_vector;
end intercon1_package;
package body intercon1_package is

function "and" (
  l : std_logic_vector;
  r : std_logic)
return std_logic_vector is
  variable result : std_logic_vector(l'range);
begin  -- "and"
  for i in l'range loop
  result(i) := l(i) and r;
end loop;  -- i
return result;
end "and";
end intercon1_package;

library IEEE;
use IEEE.std_logic_1164.all;

entity trafic_supervision is

  generic (
    priority     : integer := 1;
    tot_priority : integer := 2);

  port (
    bg           : in  std_logic;       -- bus grant
    ce           : in  std_logic;       -- clock enable
    trafic_limit : out std_logic;
    clk          : in  std_logic;
    reset        : in  std_logic);

end trafic_supervision;

architecture rtl of trafic_supervision is

  signal shreg : std_logic_vector(tot_priority-1 downto 0);
  signal cntr : integer range 0 to tot_priority;

begin  -- rtl

  -- purpose: holds information of usage of latest cycles
  -- type   : sequential
  -- inputs : clk, reset, ce, bg
  -- outputs: shreg('left)
  sh_reg: process (clk)
  begin  -- process shreg
    if clk'event and clk = '1' then  -- rising clock edge
      if ce='1' then
        shreg <= shreg(tot_priority-2 downto 0) & bg;
      end if;
    end if;
  end process sh_reg;

  -- purpose: keeps track of used cycles
  -- type   : sequential
  -- inputs : clk, reset, shreg('left), bg, ce
  -- outputs: trafic_limit
  counter: process (clk, reset)
  begin  -- process counter
    if reset = '1' then                 -- asynchronous reset (active hi)
      cntr <= 0;
      trafic_limit <= '0';
    elsif clk'event and clk = '1' then  -- rising clock edge
      if ce='1' then
        if bg='1' and shreg(tot_priority-1)/='1' then
          cntr <= cntr + 1;
          if cntr=priority-1 then
            trafic_limit <= '1';
          end if;
        elsif bg='0' and shreg(tot_priority-1)='1' then
          cntr <= cntr - 1;
          if cntr=priority then
            trafic_limit <= '0';
          end if;
        end if;
      end if;
    end if;
  end process counter;

end rtl;

library IEEE;
use IEEE.std_logic_1164.all;
use work.intercon1_package.all;

entity intercon1 is
  port (
  -- wishbone master port(s)
  -- wb1m0
  wb1m0_dat_i : out std_logic_vector(15 downto 0);
  wb1m0_ack_i : out std_logic;
  wb1m0_dat_o : in  std_logic_vector(15 downto 0);
  wb1m0_we_o  : in  std_logic;
  wb1m0_sel_o : in  std_logic_vector(1 downto 0);
  wb1m0_adr_o : in  std_logic_vector(15 downto 0);
  wb1m0_cyc_o : in  std_logic;
  wb1m0_stb_o : in  std_logic;
  -- wishbone slave port(s)
  -- wb1s0
  wb1s0_dat_o : in  std_logic_vector(15 downto 0);
  wb1s0_ack_o : in  std_logic;
  wb1s0_dat_i : out std_logic_vector(15 downto 0);
  wb1s0_we_i  : out std_logic;
  wb1s0_sel_i : out std_logic_vector(1 downto 0);
  wb1s0_adr_i : out std_logic_vector(15 downto 0);
  wb1s0_cyc_i : out std_logic;
  wb1s0_stb_i : out std_logic;
  -- wb1s1
  wb1s1_dat_o : in  std_logic_vector(15 downto 0);
  wb1s1_ack_o : in  std_logic;
  wb1s1_dat_i : out std_logic_vector(15 downto 0);
  wb1s1_we_i  : out std_logic;
  wb1s1_sel_i : out std_logic_vector(1 downto 0);
  wb1s1_adr_i : out std_logic_vector(15 downto 0);
  wb1s1_cyc_i : out std_logic;
  wb1s1_stb_i : out std_logic;
  -- clock and reset
  clk   : in std_logic;
  reset : in std_logic);
end intercon1;
architecture rtl of intercon1 is
  signal wb1m0_bg : std_logic; -- master bus grant
  signal wb1s0_ss : std_logic; -- slave select
  signal wb1s1_ss : std_logic; -- slave select
begin  -- rtl
decoder:block
  signal adr : std_logic_vector(15 downto 0);
begin
wb1m0_bg <= '1';
adr <= (wb1m0_adr_o and wb1m0_bg);
wb1s0_ss <= '1' when adr(15 downto 15)="0" else
'0';
wb1s1_ss <= '1' when adr(15 downto 13)="100" else
'0';
wb1s0_adr_i <= adr(15 downto 0);
wb1s1_adr_i <= adr(15 downto 0);
end block decoder;

mux: block
  signal cyc, stb, we, ack : std_logic;
  signal sel : std_logic_vector(1 downto 0);
  signal dat_m2s, dat_s2m : std_logic_vector(15 downto 0);
begin
cyc <= (wb1m0_cyc_o and wb1m0_bg);
wb1s0_cyc_i <= wb1s0_ss and cyc;
wb1s1_cyc_i <= wb1s1_ss and cyc;
stb <= (wb1m0_stb_o and wb1m0_bg);
wb1s0_stb_i <= stb;
wb1s1_stb_i <= stb;
we <= (wb1m0_we_o and wb1m0_bg);
wb1s0_we_i <= we;
wb1s1_we_i <= we;
ack <= wb1s0_ack_o or wb1s1_ack_o;
wb1m0_ack_i <= ack and wb1m0_bg;
sel <= (wb1m0_sel_o and wb1m0_bg);
wb1s0_sel_i <= sel;
wb1s1_sel_i <= sel;
dat_m2s <= (wb1m0_dat_o and wb1m0_bg);
wb1s0_dat_i <= dat_m2s;
wb1s1_dat_i <= dat_m2s;
dat_s2m <= (wb1s0_dat_o and wb1s0_ss) or (wb1s1_dat_o and wb1s1_ss);
wb1m0_dat_i <= dat_s2m;
end block mux;

end rtl;

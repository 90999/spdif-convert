-- Generated by PERL program wishbone.pl. Do not edit this file.
--
-- For defines see wishbone2.defines
--
-- Generated Sat Aug 18 22:57:11 2012
--
-- Wishbone masters:
--   wb2m0
--   wb2m1
--
-- Wishbone slaves:
--   wb2s0
--     baseadr 0xC0000000 - size 0x00008000
--   wb2s1
--     baseadr 0xD0000000 - size 0x00002000
--   wb2s2
--     baseadr 0xE0000000 - size 0x00000040
--     baseadr 0x00000000 - size 0x80000000
--     baseadr 0x80000000 - size 0x40000000
-----------------------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;

package intercon2_package is


function "and" (
  l : std_logic_vector;
  r : std_logic)
return std_logic_vector;
end intercon2_package;
package body intercon2_package is

function "and" (
  l : std_logic_vector;
  r : std_logic)
return std_logic_vector is
  variable result : std_logic_vector(l'range);
begin  -- "and"
  for i in l'range loop
  result(i) := l(i) and r;
end loop;  -- i
return result;
end "and";
end intercon2_package;

library IEEE;
use IEEE.std_logic_1164.all;

entity trafic_supervision is

  generic (
    priority     : integer := 1;
    tot_priority : integer := 2);

  port (
    bg           : in  std_logic;       -- bus grant
    ce           : in  std_logic;       -- clock enable
    trafic_limit : out std_logic;
    clk          : in  std_logic;
    reset        : in  std_logic);

end trafic_supervision;

architecture rtl of trafic_supervision is

  signal shreg : std_logic_vector(tot_priority-1 downto 0);
  signal cntr : integer range 0 to tot_priority;

begin  -- rtl

  -- purpose: holds information of usage of latest cycles
  -- type   : sequential
  -- inputs : clk, reset, ce, bg
  -- outputs: shreg('left)
  sh_reg: process (clk)
  begin  -- process shreg
    if clk'event and clk = '1' then  -- rising clock edge
      if ce='1' then
        shreg <= shreg(tot_priority-2 downto 0) & bg;
      end if;
    end if;
  end process sh_reg;

  -- purpose: keeps track of used cycles
  -- type   : sequential
  -- inputs : clk, reset, shreg('left), bg, ce
  -- outputs: trafic_limit
  counter: process (clk, reset)
  begin  -- process counter
    if reset = '1' then                 -- asynchronous reset (active hi)
      cntr <= 0;
      trafic_limit <= '0';
    elsif clk'event and clk = '1' then  -- rising clock edge
      if ce='1' then
        if bg='1' and shreg(tot_priority-1)/='1' then
          cntr <= cntr + 1;
          if cntr=priority-1 then
            trafic_limit <= '1';
          end if;
        elsif bg='0' and shreg(tot_priority-1)='1' then
          cntr <= cntr - 1;
          if cntr=priority then
            trafic_limit <= '0';
          end if;
        end if;
      end if;
    end if;
  end process counter;

end rtl;

library IEEE;
use IEEE.std_logic_1164.all;
use work.intercon2_package.all;

entity intercon2 is
  port (
  -- wishbone master port(s)
  -- wb2m0
  wb2m0_dat_i : out std_logic_vector(31 downto 0);
  wb2m0_ack_i : out std_logic;
  wb2m0_dat_o : in  std_logic_vector(31 downto 0);
  wb2m0_we_o  : in  std_logic;
  wb2m0_sel_o : in  std_logic_vector(3 downto 0);
  wb2m0_adr_o : in  std_logic_vector(31 downto 0);
  wb2m0_cyc_o : in  std_logic;
  wb2m0_stb_o : in  std_logic;
  -- wb2m1
  wb2m1_dat_i : out std_logic_vector(31 downto 0);
  wb2m1_ack_i : out std_logic;
  wb2m1_err_i : out std_logic;
  wb2m1_rty_i : out std_logic;
  wb2m1_dat_o : in  std_logic_vector(31 downto 0);
  wb2m1_we_o  : in  std_logic;
  wb2m1_sel_o : in  std_logic_vector(3 downto 0);
  wb2m1_adr_o : in  std_logic_vector(31 downto 0);
  wb2m1_cyc_o : in  std_logic;
  wb2m1_stb_o : in  std_logic;
  -- wishbone slave port(s)
  -- wb2s0
  wb2s0_dat_o : in  std_logic_vector(31 downto 0);
  wb2s0_ack_o : in  std_logic;
  wb2s0_dat_i : out std_logic_vector(31 downto 0);
  wb2s0_we_i  : out std_logic;
  wb2s0_sel_i : out std_logic_vector(3 downto 0);
  wb2s0_adr_i : out std_logic_vector(31 downto 0);
  wb2s0_cyc_i : out std_logic;
  wb2s0_stb_i : out std_logic;
  -- wb2s1
  wb2s1_dat_o : in  std_logic_vector(31 downto 0);
  wb2s1_ack_o : in  std_logic;
  wb2s1_dat_i : out std_logic_vector(31 downto 0);
  wb2s1_we_i  : out std_logic;
  wb2s1_sel_i : out std_logic_vector(3 downto 0);
  wb2s1_adr_i : out std_logic_vector(16 downto 0);
  wb2s1_cyc_i : out std_logic;
  wb2s1_stb_i : out std_logic;
  -- wb2s2
  wb2s2_dat_o : in  std_logic_vector(31 downto 0);
  wb2s2_ack_o : in  std_logic;
  wb2s2_err_o : in  std_logic;
  wb2s2_rty_o : in  std_logic;
  wb2s2_dat_i : out std_logic_vector(31 downto 0);
  wb2s2_we_i  : out std_logic;
  wb2s2_sel_i : out std_logic_vector(3 downto 0);
  wb2s2_adr_i : out std_logic_vector(31 downto 0);
  wb2s2_cyc_i : out std_logic;
  wb2s2_stb_i : out std_logic;
  -- clock and reset
  clk   : in std_logic;
  reset : in std_logic);
end intercon2;
architecture rtl of intercon2 is
  signal wb2m0_bg : std_logic; -- bus grant
  signal wb2m1_bg : std_logic; -- bus grant
  signal wb2s0_ss : std_logic; -- slave select
  signal wb2s1_ss : std_logic; -- slave select
  signal wb2s2_ss : std_logic; -- slave select
begin  -- rtl
arbiter_sharedbus: block
  signal wb2m0_bg_1, wb2m0_bg_2, wb2m0_bg_q : std_logic;
  signal wb2m1_bg_1, wb2m1_bg_2, wb2m1_bg_q : std_logic;
  signal wb2m0_trafic_ctrl_limit : std_logic;
  signal wb2m1_trafic_ctrl_limit : std_logic;
  signal ack, ce, idle :std_logic;
begin -- arbiter
ack <= wb2s0_ack_o or wb2s1_ack_o or wb2s2_ack_o;

trafic_supervision_1 : entity work.trafic_supervision
generic map(
  priority => 1,
  tot_priority => 2)
port map(
  bg => wb2m0_bg,
  ce => ce,
  trafic_limit => wb2m0_trafic_ctrl_limit,
  clk => clk,
  reset => reset);

trafic_supervision_2 : entity work.trafic_supervision
generic map(
  priority => 1,
  tot_priority => 2)
port map(
  bg => wb2m1_bg,
  ce => ce,
  trafic_limit => wb2m1_trafic_ctrl_limit,
  clk => clk,
  reset => reset);

process(clk,reset)
begin
if reset='1' then
  wb2m0_bg_q <= '0';
elsif clk'event and clk='1' then
if wb2m0_bg_q='0' then
  wb2m0_bg_q <= wb2m0_bg;
elsif ack='1' then
  wb2m0_bg_q <= '0';
end if;
end if;
end process;

process(clk,reset)
begin
if reset='1' then
  wb2m1_bg_q <= '0';
elsif clk'event and clk='1' then
if wb2m1_bg_q='0' then
  wb2m1_bg_q <= wb2m1_bg;
elsif ack='1' then
  wb2m1_bg_q <= '0';
end if;
end if;
end process;

idle <= '1' when wb2m0_bg_q='0' and wb2m1_bg_q='0' else '0';
wb2m0_bg_1 <= '1' when idle='1' and wb2m0_cyc_o='1' and wb2m0_trafic_ctrl_limit='0' else '0';
wb2m1_bg_1 <= '1' when idle='1' and wb2m1_cyc_o='1' and wb2m1_trafic_ctrl_limit='0' and (wb2m0_bg_1='0') else '0';
wb2m0_bg_2 <= '1' when idle='1' and (wb2m0_bg_1='0' and wb2m1_bg_1='0') and wb2m0_cyc_o='1' else '0';
wb2m1_bg_2 <= '1' when idle='1' and (wb2m0_bg_1='0' and wb2m1_bg_1='0' and wb2m0_bg_2='0') and wb2m1_cyc_o='1' else '0';
wb2m0_bg <= wb2m0_bg_q or wb2m0_bg_1 or wb2m0_bg_2;
wb2m1_bg <= wb2m1_bg_q or wb2m1_bg_1 or wb2m1_bg_2;
ce <= wb2m0_cyc_o or wb2m1_cyc_o when idle='1' else '0';

end block arbiter_sharedbus;

decoder:block
  signal adr : std_logic_vector(31 downto 0);
begin
adr <= (wb2m0_adr_o and wb2m0_bg) or (wb2m1_adr_o and wb2m1_bg);
wb2s0_ss <= '1' when adr(31 downto 15)="11000000000000000" else
'0';
wb2s1_ss <= '1' when adr(31 downto 13)="1101000000000000000" else
'0';
wb2s2_ss <= '1' when adr(31 downto 6)="11100000000000000000000000" else
'1' when adr(31 downto 31)="0" else
'1' when adr(31 downto 30)="10" else
'0';
wb2s0_adr_i <= adr(31 downto 0);
wb2s1_adr_i <= adr(16 downto 0);
wb2s2_adr_i <= adr(31 downto 0);
end block decoder;

mux: block
  signal cyc, stb, we, ack : std_logic;
  signal sel : std_logic_vector(3 downto 0);
  signal dat_m2s, dat_s2m : std_logic_vector(31 downto 0);
begin
cyc <= (wb2m0_cyc_o and wb2m0_bg) or (wb2m1_cyc_o and wb2m1_bg);
wb2s0_cyc_i <= wb2s0_ss and cyc;
wb2s1_cyc_i <= wb2s1_ss and cyc;
wb2s2_cyc_i <= wb2s2_ss and cyc;
stb <= (wb2m0_stb_o and wb2m0_bg) or (wb2m1_stb_o and wb2m1_bg);
wb2s0_stb_i <= stb;
wb2s1_stb_i <= stb;
wb2s2_stb_i <= stb;
we <= (wb2m0_we_o and wb2m0_bg) or (wb2m1_we_o and wb2m1_bg);
wb2s0_we_i <= we;
wb2s1_we_i <= we;
wb2s2_we_i <= we;
ack <= wb2s0_ack_o or wb2s1_ack_o or wb2s2_ack_o;
wb2m0_ack_i <= ack and wb2m0_bg;
wb2m1_ack_i <= ack and wb2m1_bg;
wb2m1_rty_i <= wb2s2_rty_o;
wb2m1_err_i <= wb2s2_err_o;
sel <= (wb2m0_sel_o and wb2m0_bg) or (wb2m1_sel_o and wb2m1_bg);
wb2s0_sel_i <= sel;
wb2s1_sel_i <= sel;
wb2s2_sel_i <= sel;
dat_m2s <= (wb2m0_dat_o and wb2m0_bg) or (wb2m1_dat_o and wb2m1_bg);
wb2s0_dat_i <= dat_m2s;
wb2s1_dat_i <= dat_m2s;
wb2s2_dat_i <= dat_m2s;
dat_s2m <= (wb2s0_dat_o and wb2s0_ss) or (wb2s1_dat_o and wb2s1_ss) or (wb2s2_dat_o and wb2s2_ss);
wb2m0_dat_i <= dat_s2m;
wb2m1_dat_i <= dat_s2m;
end block mux;

end rtl;
